<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb" lang="en" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="链表类型的算法题">
  <meta name="generator" content="Hugo 0.74.3" />

  <title>Linked list problems solution &middot; 戈壁堂</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="http://gebitang.com/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="http://gebitang.com/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="http://gebitang.com/css/blackburn.css">

  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="http://gebitang.com/img/favicon.ico" type="image/x-icon" />

  
    
        <link rel="stylesheet" href="http://gebitang.com/css/my.css">
    
  
  
    
        <script src="http://gebitang.com/js/my.js"></script>
    
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="http://gebitang.com/">Gebitang</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://gebitang.com/topics/"><i class='fa fa-folder fa-fw'></i>Topics</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>

  <div class="small-print">
  	<small>
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br/>本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由<a xmlns:cc="http://creativecommons.org/ns#" href="http://gebitang.com" property="cc:attributionName" rel="cc:attributionURL">&nbsp;Gebitang&nbsp;&nbsp;</a>采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可&nbsp;&copy; 2018
    </small>

  </div>

  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>

  <div style="display:none">
  <div class="small-print">
    <small>
    <wb:follow-button uid="2446212465" type="red_1" width="67" height="24"></wb:follow-button>
  </small>
  </div>
  </div>

</div>

</div>


  <div id="main">


<div class="header">
  <h1>Linked list problems solution</h1>
  <h2>链表类型的算法题</h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2019-10-21</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://gebitang.com/topics/tech">tech</a>&nbsp;&#47;
    
      <a class="post-taxonomy-topic" href="http://gebitang.com/topics/algo">algo</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://gebitang.com/tags/algo">algo</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="http://gebitang.com/tags/list">list</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="http://gebitang.com/tags/linked-list">linked-list</a>
    
  </div>
  
  

</div>

  
	<nav id="TableOfContents">
  <ul>
    <li><a href="#problem-2-add-two-numbers">Problem 2 Add Two Numbers</a>
      <ul>
        <li><a href="#refer">Refer</a></li>
      </ul>
    </li>
    <li><a href="#problem-19-remove-nth-node-from-end-of-list">Problem 19 Remove Nth Node From End of List</a></li>
    <li><a href="#problem-21-merge-two-sorted-lists">Problem 21: Merge Two Sorted Lists</a></li>
    <li><a href="#problem-61-rotate-list">Problem 61: Rotate List</a></li>
    <li><a href="#problem-83-remove-duplicates-from-sorted-list">Problem 83: Remove Duplicates from Sorted List</a></li>
  </ul>
</nav>
  

  <p><a href="https://leetcode.com/tag/linked-list/">linked-list</a></p>
<h2 id="problem-2-add-two-numbers">Problem 2 Add Two Numbers</h2>
<p><a href="https://leetcode.com/problems/add-two-numbers/">2. Add Two Numbers Medium</a></p>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
</code></pre><p>1 - 读取两个链表构造为顺序的list，分别得到342,464
2 - 获取和
3 - 重新构造新的ListNode</p>
<pre><code>public class ListNode{
        int val;
        ListNode next;
        ListNode(int x) {
            this.val = x;
        }
    }

public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

        String i1 = readToNumber(l1);
        String i2 = readToNumber(l2);

        String s = addTwoStr(i1, i2);

        ListNode node = null;
        ListNode t = null;
        for (int i = s.length() - 1; i &gt;=0 ; i--) {
            int v = Integer.parseInt(String.valueOf(s.charAt(i)));
            ListNode temp = new ListNode(v);
            if(node != null) {
                node.next = temp;
                node = node.next;
            }else {
                node = temp;
                t = temp;
            }
        }

        return t;
    }

    private String readToNumber(ListNode node) {
        String s = &quot;&quot;;
        while (node != null) {
            s = node.val + s;
            node = node.next;
        }

        return s;
    }

    private static String addTwoStr(String s, String y) {
        int max = Math.max(s.length(), y.length());
        int t = 0;
        String v = &quot;&quot;;
        for (int i = 0; i &lt; max ; i++) {
            int s1 = i &gt; s.length() -1 ? 0 : Integer.parseInt(String.valueOf(s.charAt(s.length() - 1 -i)));
            int y1 = i &gt; y.length() -1 ? 0 : Integer.parseInt(String.valueOf(y.charAt(y.length() - 1 -i)));
            int c =(s1+y1+ t) % 10 ;
            t = s1+y1+t &gt;= 10 ? 1 : 0 ;
            v = c + v;
        }

        if(t &gt; 0) {
            v = 1 + v;
        }
        return v;
    }

</code></pre><p>第2步需要处理为String，否则可能越界。问题装换为数字格式的两个数组进行位置求和。但看起来我这个算法好复杂啊- -||</p>
<p>检查先练习再说吧:(</p>
<p>晚上也算做出来了——这个“数字字符串”的“求和”有点“特殊化”了</p>
<pre><code>private static String addTwoStr(String s, String y) {
        int max = Math.max(s.length(), y.length());
        int t = 0;
        String v = &quot;&quot;;
        for (int i = 0; i &lt; max ; i++) {
            int s1 = i &gt; s.length() -1 ? 0 : Integer.parseInt(String.valueOf(s.charAt(s.length() - 1 -i)));
            int y1 = i &gt; y.length() -1 ? 0 : Integer.parseInt(String.valueOf(y.charAt(y.length() - 1 -i)));
            int c =(s1+y1+ t) % 10 ;
            t = s1+y1+t &gt;= 10 ? 1 : 0 ;
            v = c + v;
        }

        if(t &gt; 0) {
            v = 1 + v;
        }
        return v;
    }
</code></pre><p>Runtime: 7 ms, faster than 5.04% of Java online submissions for Add Two Numbers.
Memory Usage: 39.7 MB, less than 99.69% of Java online submissions for Add Two Numbers.</p>
<p><a href="https://leetcode.com/problems/add-two-numbers/discuss/1059/My-accepted-Java-solution">更高效的解决方法</a></p>
<h3 id="refer">Refer</h3>
<pre><code>/**
Runtime: 1 ms, faster than 99.99% of Java online submissions for Add Two Numbers.
Memory Usage: 44.8 MB, less than 85.58% of Java online submissions for Add Two Numbers.
*/
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode prev = new ListNode(0);
        ListNode head = prev;
        int carry = 0;
        while (l1 != null || l2 != null || carry != 0) {
            
            ListNode cur = l1!=null?l1:(l2!=null?l2:(new ListNode(0)));
            
            
            int sum = ((l1 == null) ? 0 : l1.val) + ((l2 == null) ? 0 : l2.val) + carry;
            cur.val = sum % 10;
            carry = sum / 10;
            
            //挂上当前节点
            prev.next = cur;
            // 移动指针到下一个位置，为下一次挂节点做准备
            prev = prev.next;
            
            l1 = (l1 == null) ? l1 : l1.next;
            l2 = (l2 == null) ? l2 : l2.next;
        }
        return head.next;
    }
</code></pre><p>看完别人的解法，感觉我对题目理解的有问题。<strong>reverse order</strong>实际上正好满足正确的加法计算规则。<code>[2-&gt;4-&gt;5]  +  [3 -&gt; 6 -&gt; 9]</code> 对应于 542+964，计算时正好是按照顺序从第一位2、3开始计算加法</p>
<hr>
<h2 id="problem-19-remove-nth-node-from-end-of-list">Problem 19 Remove Nth Node From End of List</h2>
<p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List </a></p>
<p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre><p><strong>Note:</strong> Given <code>n</code> will always be valid.
<strong>Follow up:</strong> Could you do this in one pass?</p>
<p>笨办法：从头走到尾，找到第N位；再重新……</p>
<p>直接上手写到这一步就懵了—— 如何进行链表节点的摘取还是不清楚。</p>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {

        if(head == null ||  n &lt;= 0) return head;

        int i = 0;
        ListNode node = head;
        while (node != null) {
            i++;
            node = node.next;
        }

        int s = i - n;

        node = head;
        if(i == 0) {
            return node.next;
        }else {
            ListNode f = node;
            int step = 0;
        }

        return  null;

    }
</code></pre><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.
Memory Usage: 35.1 MB, less than 100.00% of Java online submissions for Remove Nth Node From End of List.</p>
<p>看了网上的<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/discuss/8804/Simple-Java-solution-in-one-pass">实现</a></p>
<ol>
<li>先固定头部：创建一个新的头节点，让头结点的下一个节点指向传入的节点</li>
<li>将链表复制多份，操作多个备份，只“读”不“写”，所以不会对原始的链表产生“破坏”。</li>
<li>实际对应链表的操作只有一步：跳过需要处理的节点。</li>
<li>找到头部节点的下一个节点。</li>
</ol>
<p>只循环一次的逻辑：需要两个“指针”同时跑——所有类似的一次循环都需要用到所谓的“快慢指针”。</p>
<p>关键点：先让一个备份跑n步。然后再同时跑两个备份，先跑的走到头之后，就是要找的位置。</p>
<p>明天来试试自己实现这个算法。</p>
<hr>
<p>我以为我理解了这个算法的关键，但在自己的实现上执行时，还是没写出来应该怎么计算位置。参考上面的实现——</p>
<ul>
<li>要走到要摘除的节点的前一个节点就停止。（否则：走到要拆除的节点位置时，时不知道前一个节点是什么的）</li>
<li>需要先创建一个节点保存原始的位置：最后返回时返回next节点。——为什么这样操作？如果不使用占位节点如何实现？还不清楚:(</li>
</ul>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {

        if(head == null ||  n &lt;= 0) return head;

        int i = 0;
        ListNode node = head;
        while (node != null) {
            i++;
            node = node.next;
        }

        int s = i - n;

        node = head;
        if(s == 0) {
            return node.next;
        }else {
            //新建一个节点
            ListNode f = new ListNode(0);
            ListNode temp = f;
            temp.next = node;
            while (s &gt; 0) {
               temp = temp.next;
                s--;
            }
            //temp.next 为要移除的节点
            temp.next = temp.next.next;
            return f.next;

        }

    }
</code></pre><hr>
<h2 id="problem-21-merge-two-sorted-lists">Problem 21: Merge Two Sorted Lists</h2>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a> Easy</p>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<blockquote>
<pre><code>Example:

Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre>
</blockquote>
<p>这是个Easy级别的，有前两次的经验，一次做对，但执行效率不高</p>
<blockquote>
<p>Runtime: 1 ms, faster than 23.66% of Java online submissions for Merge Two Sorted Lists.
Memory Usage: 39.5 MB, less than 16.84% of Java online submissions for Merge Two Sorted Lists.</p>
</blockquote>
<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        if(l1==null) {
            return l2;
        }
        if(l2==null) {
            return l1;
        }

        ListNode n = new ListNode(0);
        ListNode temp = n;
        int j , k;
        while (l1 != null || l2 != null) {

            if(l1 ==null) {
                temp.next = new ListNode(l2.val);
                temp = temp.next;
                l2 = l2.next;
                continue;
            }

            if(l2 ==null) {
                temp.next = new ListNode(l1.val);
                temp = temp.next;
                l1 = l1.next;
                continue;
            }

            j= l1.val;
            k = l2.val;

            if(j==k) {
                temp.next = new ListNode(j);
                temp = temp.next;

                temp.next = new ListNode(k);
                temp = temp.next;

                l1 = l1.next;
                l2 = l2.next;

            }else if(j &gt; k) {
                temp.next = new ListNode(k);
                temp = temp.next;
                l2 = l2.next;
            }else {
                temp.next = new ListNode(j);
                temp = temp.next;
                l1 = l1.next;
            }

        }

        return n.next;
    }
</code></pre><p>学习一下<a href="https://leetcode.com/problems/merge-two-sorted-lists/discuss/?currentPage=1&amp;orderBy=most_votes&amp;query=">讨论区</a>的高效方法——</p>
<p>几点改进的地方：</p>
<ol>
<li>循环处理为 且的关系，（关键点）</li>
<li>结束循环后再分别判断两个链表的情况</li>
<li>直接使用节点本身进行挂载，不需要新建（那为什么我采用新建的反而占用内存更少？新建的只包含一个节点。验证了一下使用新建也只是降低了0.1MB的内存占用）</li>
<li>不需要特殊处理相等的条件；</li>
</ol>
<pre><code>/**
     Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Sorted Lists.
     Memory Usage: 40.7 MB, less than 11.78% of Java online submissions for Merge Two Sorted Lists
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode n = new ListNode(0);
        ListNode temp = n;
        while (l1 != null &amp;&amp; l2 != null) {

            if(l1.val &gt;= l2.val) {
                temp.next = l2;
                temp = temp.next;
                l2 = l2.next;
            }else {
                temp.next = l1;
                temp = temp.next;
                l1 = l1.next;
            }
        }

        if(l1 != null) {
            temp.next = l1;
        }

        if(l2 != null) {
            temp.next = l2;
        }
        return n.next;
    }
</code></pre><h2 id="problem-61-rotate-list">Problem 61: Rotate List</h2>
<p><a href="https://leetcode.com/problems/rotate-list/">Rotate List</a> Medium</p>
<p>Given a linked list, rotate the list to the right by k places, where <code>k</code> is non-negative.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>
Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<p>Explanation:</p>
<blockquote>
<p>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>
rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>
Output: 2-&gt;0-&gt;1-&gt;NULL</p>
</blockquote>
<p>Explanation:</p>
<blockquote>
<p>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>
rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>
rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>
rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</p>
</blockquote>
<p>对比后可知，k有可能大于整个链表的长度，需要判断出来实际上需要翻转的位置。 所以必须要获取链表的长度。
获取长度之后，要翻转的位置为 S 个位置（int s = k % size）。</p>
<p>自己写的时候，总是不好控制要移动到哪个位置。——目前看，链表题都需要先手动添加一个 dummy节点，然后将head节点挂在这个dummy节点的下一个位置。</p>
<p>然后操作时，都直接操作dummy这个新链表。这样确保操作的最终目标都是移动之后的 target.next节点。</p>
<pre><code>public ListNode rotateRight(ListNode head, int k) {

        if (head==null||head.next==null) return head;

        ListNode dummy=new ListNode(0);
        dummy.next=head;

        ListNode fast=dummy,slow=dummy;

        int size= 0; //链表长度
        while (fast.next != null) {
            fast = fast.next;
            size++;
        }

        int s = k % size; //移动次数

        if(s == 0) return dummy.next; //不需要移动

        for (int i = 0; i &lt; (size - s); i++) { //要移动的位数
            slow=slow.next;
        }

        //关键的翻转操作
        fast.next=dummy.next; //最后一个节点的next需要指向最初的头结点
        dummy.next=slow.next; // slow.next是目前新的头结点
        slow.next=null; //将slow.next节点至为null。完成翻转动作

        return dummy.next;

    }
</code></pre><h2 id="problem-83-remove-duplicates-from-sorted-list">Problem 83: Remove Duplicates from Sorted List</h2>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a> Easy</p>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: 1-&gt;1-&gt;2<br>
Output: 1-&gt;2</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>
Output: 1-&gt;2-&gt;3</p>
</blockquote>
<p>直接的实现对于最后一个节点的处理不够精细，调试后完成了算法。</p>
<p>Runtime: 2 ms, faster than 6.29% of Java online submissions for Remove Duplicates from Sorted List.<br>
Memory Usage: 36.9 MB, less than 100.00% of Java online submissions for Remove Duplicates from Sorted List.</p>
<pre><code>public ListNode deleteDuplicates(ListNode head) {

        if(head == null || head.next == null) return head;

        List&lt;Integer&gt; unique = new ArrayList&lt;&gt;();

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode t = dummy;
        while (head != null) {
            int v = head.val;
            if(!unique.contains(v)) {
                unique.add(v);
                t.next = head;
                t = t.next;
                head = head.next;
            }else {
                head = head.next;
                if(head == null) {
                    t.next = null; //最后一个节点断开
                    break;
                }
            }
        }
        return dummy.next;
    }
</code></pre>
  
  

  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="http://gebitang.com/post/how/apple-dev/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="http://gebitang.com/post/how/apple-dev/">How to develop on MacOS for Apple platform</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="http://gebitang.com/post/how/mysql/">Mysql</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="http://gebitang.com/post/how/mysql/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'gebitang';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="http://gebitang.com/js/ui.js"></script>
<script src="http://gebitang.com/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-34303694-1', 'auto');
    ga('send', 'pageview');
  }
</script>




<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
</body>
</html>

