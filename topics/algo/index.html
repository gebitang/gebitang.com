<!doctype html><html xmlns:wb=http://open.weibo.com/wb lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.121.2"><title>algo &#183; 戈壁堂</title>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=http://gebitang.com/css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=http://gebitang.com/css/side-menu.css><!--<![endif]--><link rel=stylesheet href=http://gebitang.com/css/blackburn.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.9.0/css/all.css><link href="https://fonts.googleapis.com/css?family=Raleway" rel=stylesheet type=text/css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel=alternate type=application/rss+xml title=戈壁堂 href=http://gebitang.com/topics/algo/index.xml><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js></script><script>hljs.initHighlightingOnLoad()</script><link rel="shortcut icon" href=http://gebitang.com/img/favicon.ico type=image/x-icon><link rel=stylesheet href=http://gebitang.com/css/my.css><script src=http://gebitang.com/js/my.js></script></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><a class="pure-menu-heading brand" href=http://gebitang.com/>Gebitang</a><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/><i class='fa fa-home fa-fw'></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/post/><i class='fa fa-list fa-fw'></i>Posts</a></li><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/about/><i class='fa fa-user fa-fw'></i>About</a></li><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/contact/><i class='fa fa-phone fa-fw'></i>Contact</a></li><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/tags/><i class='fa fa-tags fa-fw'></i>Tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/topics/><i class='fa fa-folder fa-fw'></i>Topics</a></li></ul></div><div class="pure-menu social"><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=http://gebitang.com/topics/algo/index.xml><i class="fas fa-rss"></i>RSS</a></li></ul></div><div><div class=small-print><small><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by/4.0/80x15.png></a><br>本<span xmlns:dct=http://purl.org/dc/terms/ href=http://purl.org/dc/dcmitype/Text rel=dct:type>作品</span>由<a xmlns:cc=http://creativecommons.org/ns# href=http://gebitang.com property="cc:attributionName" rel=cc:attributionURL>&nbsp;Gebitang&nbsp;&nbsp;</a>采用<a rel=license href=http://creativecommons.org/licenses/by/4.0/>知识共享署名 4.0 国际许可协议</a>进行许可&nbsp;&copy; 2018</small></div><div class=small-print><small></small></div><div class=small-print><small>Built with&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a></small>
<small>Theme&nbsp;<a href=https://github.com/yoshiharuyamashita/blackburn target=_blank>Blackburn</a></small></div><div style=display:none><div class=small-print><small><wb:follow-button uid=2446212465 type=red_1 width=67 height=24></wb:follow-button></small></div></div></div></div><div id=main><div class=header><h1>algo</h1></div><div class=content><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%80--p2/>算法练习LinkedList(一)--P2</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 已废弃，参考&ndash;算法练习LinkedList(三): P2、P19 linked-list 2. Add Two Numbers Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%80--p2/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%83--p82/>算法练习LinkedList(七)--P82</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu Remove Duplicates from Sorted List 2 Medium Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 昨天做得有点郁闷了。‘精准原子’操作的套路还是没有掌握，</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%83--p82/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%89--p2p19/>算法练习LinkedList(三)--P2、P19</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu linked-list Medium 2. Add Two Numbers Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%89--p2p19/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B9%9D--p92/>算法练习LinkedList(九)--P92</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL 可以先复习一下翻转链表的实现。链表操作两个基本场景—— 将</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B9%9D--p92/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%8C--p19/>算法练习LinkedList(二)--P19</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 已废弃，参考&ndash;算法练习LinkedList(三): P2、P19 19. Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5,</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%8C--p19/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%94--p61/>算法练习LinkedList(五)--P61</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu Rotate List Medium Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right:</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%94--p61/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AB--p86/>算法练习LinkedList(八)--P86</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 86. Partition List Medium Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5 梳理一下思路，应该很快</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AB--p86/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AD--p83/>算法练习LinkedList(六)--P83</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu Remove Duplicates from Sorted List Easy Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 直接的实现对于最后一个节点的处理不够精细，调试后完成了算法。 Runtime: 2 ms, faster</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AD--p83/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81--p138/>算法练习LinkedList(十)--P138</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Java中的深拷贝：对象中的对象需要重写clone方法，将</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81--p138/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81%E4%B8%80--p109/>算法练习LinkedList(十一)--P109</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 109. Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81%E4%B8%80--p109/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%9B%9B--p21/>算法练习LinkedList(四)--P21</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 21. Merge Two Sorted Lists Easy Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 这是个Easy级别的，有前两次的经验，一次做对，但执行</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%9B%9B--p21/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1021-easy/>算法练习Stack--P1021-easy</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 1021. Remove Outermost Parentheses A valid parentheses string is either empty (""), &ldquo;(&rdquo; + A + &ldquo;)&rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &ldquo;&rdquo;, &ldquo;()&rdquo;, &ldquo;(())()&rdquo;, and &ldquo;(()(()))&rdquo; are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1021-easy/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1047-easy/>算法练习Stack--P1047-easy</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 1047. Remove All Adjacent Duplicates In String Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique. Example 1:</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1047-easy/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p144-medium/>算法练习Stack--P144-Medium</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 144. Binary Tree Preorder Traversal Medium Given a binary tree, return the preorder traversal of its nodes&rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? 前序就是根节点在最前根->左-></p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p144-medium/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p145-hard/>算法练习Stack--P145-Hard</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 145. Binary Tree Postorder Traversal Hard Given a binary tree, return the postorder traversal of its nodes&rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? 后序遍历在访问完左子树向上回退到根节点的时候</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p145-hard/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p844-easy/>算法练习Stack--P844-easy</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 844. Backspace String Compare Easy Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = &ldquo;ab#c&rdquo;, T = &ldquo;ad#c&rdquo; Output: true Explanation: Both S and T become &ldquo;ac&rdquo;. Note: 1 &lt;= S.length &lt;= 200 1 &lt;= T.length &lt;= 200 S and T</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p844-easy/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p94-medium/>算法练习Stack--P94-Medium</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 94. Binary Tree Inorder Traversal Medium Given a binary tree, return the inorder traversal of its nodes&rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 先了解一下 preorder (前序)，inorder(中序)</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p94-medium/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%80--p20/>算法练习Stack(一)--P20</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack valid parentheses Given a string containing just the characters &lsquo;(&rsquo;, &lsquo;)&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;, &lsquo;[&rsquo; and &lsquo;]&rsquo;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. 先从最</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%80--p20/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%83--p496/>算法练习Stack(七)--P496</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 496. Next Greater Element I Easy You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%83--p496/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%89--p42/>算法练习Stack(三)--P42</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 42. Trapping Rain Water Hard Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example:</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%89--p42/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%8C--p71/>算法练习Stack(二)--P71</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 71. simplify path Medium Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%8C--p71/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%94--p225232/>算法练习Stack(五)--P225、232</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 225. Implement Stack using Queues Easy 232. Implement Queue using Stacks Easy 这两道提互为实现，刚好放到一起学习。既然两种数据结构可以互相实现，可以看看有什么相似之处。 队列qu</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%94--p225232/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%85%AD--p173/>算法练习Stack(六)--P173</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 173. Binary Search Tree Iterator Medium Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext();</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%85%AD--p173/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%9B%9B--p155/>算法练习Stack(四)--P155</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2020-03-07</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/jiansh>jiansh</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>Algo</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/jiansh>jiansh</a></div></div></header><p>link on JianShu 栈stack 155. Min Stack Easy Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) &ndash; Push element x onto stack. pop() &ndash; Removes the element on top of the stack. top() &ndash; Get the top element. getMin() &ndash; Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3);</p><footer><a href=http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%9B%9B--p155/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/algo/problems/>Problems</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2019-04-24</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>algo</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/tech>tech</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/algo>algo</a>&nbsp;/
<a class=post-taxonomy-tag href=http://gebitang.com/tags/sorts>sorts</a></div></div></header><p><p>list of all Problems from leetcode.</p></p><footer><a href=http://gebitang.com/post/algo/problems/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=http://gebitang.com/post/algo/algo-issues/>Algo issues</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>2019-04-15</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=http://gebitang.com/topics/algo>algo</a>&nbsp;/
<a class=post-taxonomy-topic href=http://gebitang.com/topics/tech>tech</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=http://gebitang.com/tags/algo>algo</a>&nbsp;/
<a class=post-taxonomy-tag href=http://gebitang.com/tags/sorts>sorts</a></div></div></header><p>第一周题目 链表 简单：https://leetcode.com/problems/remove-duplicates-from-sorted-</p><footer><a href=http://gebitang.com/post/algo/algo-issues/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article></div></div></div><script src=http://gebitang.com/js/ui.js></script><script src=http://gebitang.com/js/menus.js></script><script>window.location.hostname!="localhost"&&(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-34303694-1","auto"),ga("send","pageview"))</script><button onclick=topFunction() id=myBtn title="Go to top">Top</button></body></html>