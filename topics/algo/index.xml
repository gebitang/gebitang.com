<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algo on 戈壁堂</title><link>http://gebitang.com/topics/algo/</link><description>Recent content in Algo on 戈壁堂</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 07 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://gebitang.com/topics/algo/index.xml" rel="self" type="application/rss+xml"/><item><title>算法练习LinkedList(一)--P2</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%80--p2/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%80--p2/</guid><description>link on JianShu 已废弃，参考&amp;ndash;算法练习LinkedList(三): P2、P19 linked-list 2. Add Two Numbers Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain</description></item><item><title>算法练习LinkedList(七)--P82</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%83--p82/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%83--p82/</guid><description>link on JianShu Remove Duplicates from Sorted List 2 Medium Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5 Example 2: Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3 昨天做得有点郁闷了。‘精准原子’操作的套路还是没有掌握，</description></item><item><title>算法练习LinkedList(三)--P2、P19</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%89--p2p19/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B8%89--p2p19/</guid><description>link on JianShu linked-list Medium 2. Add Two Numbers Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&amp;gt; 4</description></item><item><title>算法练习LinkedList(九)--P92</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B9%9D--p92/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%B9%9D--p92/</guid><description>link on JianShu 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 可以先复习一下翻转链表的实现。链表操作两个基本场景—— 将</description></item><item><title>算法练习LinkedList(二)--P19</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%8C--p19/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%8C--p19/</guid><description>link on JianShu 已废弃，参考&amp;ndash;算法练习LinkedList(三): P2、P19 19. Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5,</description></item><item><title>算法练习LinkedList(五)--P61</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%94--p61/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E4%BA%94--p61/</guid><description>link on JianShu Rotate List Medium Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2: Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right:</description></item><item><title>算法练习LinkedList(八)--P86</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AB--p86/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AB--p86/</guid><description>link on JianShu 86. Partition List Medium Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;2, x = 3 Output: 1-&amp;gt;2-&amp;gt;2-&amp;gt;4-&amp;gt;3-&amp;gt;5 梳理一下思路，应该很快</description></item><item><title>算法练习LinkedList(六)--P83</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AD--p83/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%85%AD--p83/</guid><description>link on JianShu Remove Duplicates from Sorted List Easy Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2: Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 直接的实现对于最后一个节点的处理不够精细，调试后完成了算法。 Runtime: 2 ms, faster</description></item><item><title>算法练习LinkedList(十)--P138</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81--p138/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81--p138/</guid><description>link on JianShu 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Java中的深拷贝：对象中的对象需要重写clone方法，将</description></item><item><title>算法练习LinkedList(十一)--P109</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81%E4%B8%80--p109/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%8D%81%E4%B8%80--p109/</guid><description>link on JianShu 109. Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer</description></item><item><title>算法练习LinkedList(四)--P21</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%9B%9B--p21/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0linkedlist%E5%9B%9B--p21/</guid><description>link on JianShu 21. Merge Two Sorted Lists Easy Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 这是个Easy级别的，有前两次的经验，一次做对，但执行</description></item><item><title>算法练习Stack--P1021-easy</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1021-easy/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1021-easy/</guid><description>link on JianShu 栈stack 1021. Remove Outermost Parentheses A valid parentheses string is either empty (&amp;quot;&amp;quot;), &amp;ldquo;(&amp;rdquo; + A + &amp;ldquo;)&amp;rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &amp;ldquo;&amp;rdquo;, &amp;ldquo;()&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, and &amp;ldquo;(()(()))&amp;rdquo; are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not</description></item><item><title>算法练习Stack--P1047-easy</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1047-easy/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p1047-easy/</guid><description>link on JianShu 栈stack 1047. Remove All Adjacent Duplicates In String Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique. Example 1:</description></item><item><title>算法练习Stack--P144-Medium</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p144-medium/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p144-medium/</guid><description>link on JianShu 栈stack 144. Binary Tree Preorder Traversal Medium Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? 前序就是根节点在最前根-&amp;gt;左-&amp;gt;</description></item><item><title>算法练习Stack--P145-Hard</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p145-hard/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p145-hard/</guid><description>link on JianShu 栈stack 145. Binary Tree Postorder Traversal Hard Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? 后序遍历在访问完左子树向上回退到根节点的时候</description></item><item><title>算法练习Stack--P844-easy</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p844-easy/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p844-easy/</guid><description>link on JianShu 栈stack 844. Backspace String Compare Easy Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = &amp;ldquo;ab#c&amp;rdquo;, T = &amp;ldquo;ad#c&amp;rdquo; Output: true Explanation: Both S and T become &amp;ldquo;ac&amp;rdquo;. Note: 1 &amp;lt;= S.length &amp;lt;= 200 1 &amp;lt;= T.length &amp;lt;= 200 S and T</description></item><item><title>算法练习Stack--P94-Medium</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p94-medium/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack--p94-medium/</guid><description>link on JianShu 栈stack 94. Binary Tree Inorder Traversal Medium Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 先了解一下 preorder (前序)，inorder(中序)</description></item><item><title>算法练习Stack(一)--P20</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%80--p20/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%80--p20/</guid><description>link on JianShu 栈stack valid parentheses Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. 先从最</description></item><item><title>算法练习Stack(七)--P496</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%83--p496/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%83--p496/</guid><description>link on JianShu 栈stack 496. Next Greater Element I Easy You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its</description></item><item><title>算法练习Stack(三)--P42</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%89--p42/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%B8%89--p42/</guid><description>link on JianShu 栈stack 42. Trapping Rain Water Hard Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example:</description></item><item><title>算法练习Stack(二)--P71</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%8C--p71/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%8C--p71/</guid><description>link on JianShu 栈stack 71. simplify path Medium Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that</description></item><item><title>算法练习Stack(五)--P225、232</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%94--p225232/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E4%BA%94--p225232/</guid><description>link on JianShu 栈stack 225. Implement Stack using Queues Easy 232. Implement Queue using Stacks Easy 这两道提互为实现，刚好放到一起学习。既然两种数据结构可以互相实现，可以看看有什么相似之处。 队列qu</description></item><item><title>算法练习Stack(六)--P173</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%85%AD--p173/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%85%AD--p173/</guid><description>link on JianShu 栈stack 173. Binary Search Tree Iterator Medium Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext();</description></item><item><title>算法练习Stack(四)--P155</title><link>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%9B%9B--p155/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/jiansh/algo/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0stack%E5%9B%9B--p155/</guid><description>link on JianShu 栈stack 155. Min Stack Easy Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. getMin() &amp;ndash; Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3);</description></item><item><title>Problems</title><link>http://gebitang.com/post/algo/problems/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/algo/problems/</guid><description>&lt;p>list of all Problems from leetcode.&lt;/p></description></item><item><title>Algo issues</title><link>http://gebitang.com/post/algo/algo-issues/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>http://gebitang.com/post/algo/algo-issues/</guid><description>第一周题目 链表 简单：https://leetcode.com/problems/remove-duplicates-from-sorted-</description></item></channel></rss>